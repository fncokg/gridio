{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"gridio","text":"<p>Rust-powered TextGrid parsing for Python. <code>gridio</code> offers user-friendly APIs with high performance for manipulating Praat TextGrid files.</p>"},{"location":"#why-gridio","title":"Why gridio?","text":"<ul> <li>High Performance \u2013 Built with Rust, <code>gridio</code> is designed for speed and efficiency, outperforming pure Python implementations as well as bindings to Praat's C++ core.</li> <li>Flexible APIs \u2013 Whether you prefer working with DataFrames, object-oriented structures, or JSON-like data, <code>gridio</code> has you covered.</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#i-want-simplicity","title":"I want simplicity","text":"<p>No structures. No classes. Just load and save DataFrames.</p> <pre><code>from gridio import textgrid_to_df, df_to_textgrid\n\ndf = textgrid_to_df(\"data/short_format.TextGrid\")\nprint(df.head())\n\ndf_to_textgrid(df, \"output.TextGrid\", file_type=\"short\")\n</code></pre>"},{"location":"#i-want-full-control","title":"I want full control","text":"<p>You can manipulate TextGrid files with a OOP-style API.</p> <pre><code>from gridio import TextGrid, Tier, IntervalItem\n\ntg: TextGrid = TextGrid.from_file(\"data/long_format.TextGrid\")\nphones: Tier = tg.get_tier(\"phone\")\nnew_item: IntervalItem = IntervalItem(1.23, 1.45, \"ah\")\nphones.insert_item(new_item, index=0)\n\ntg.save(\"edited.TextGrid\", file_type=\"long\")\n</code></pre> <p>No worry about performance, all of those OOP objects are lazy created from raw data only when accessed.</p>"},{"location":"#you-can-even-work-with-a-json-like-data-structure","title":"You can even work with a JSON-like data structure.","text":"<p>With <code>textgrid_to_data</code> and <code>data_to_textgrid</code>, convert between TextGrid files and nested lists/dicts. They're easy to serialize (e.g., to JSON) and manipulate programmatically.</p> <pre><code>from gridio import textgrid_to_data, data_to_textgrid\n\ndata = textgrid_to_data(\"data/long_format.TextGrid\")\nprint(data[0], data[1])  # global tmin/tmax\nfirst_tier = data[2][0]\nprint(first_tier[0], first_tier[2][:2])\n\ndata_to_textgrid(data, \"copy.TextGrid\")\n</code></pre>"},{"location":"#install","title":"Install","text":"<p>You can install <code>gridio</code> via pip:</p> <pre><code>pip install gridio\n</code></pre> <p>Or if you want to build from source, make sure you have Rust and maturin installed, then run:</p> <pre><code>maturin develop\n</code></pre>"},{"location":"#benchmarks","title":"Benchmarks","text":"<p>We benchmark <code>gridio</code> against two popular TextGrid parsing libraries: <code>textgrid</code> (a pure Python implementation) and <code>parselmouth</code> (Python bindings for Praat). </p> <p>The benchmarks focus on two common tasks:  - constructing in-memory TextGrid objects - converting TextGrids to Pandas DataFrames</p> <p>The results are summarized below:</p> Package Task Mean (s) Std Dev (s) Speedup gridio construct 0.984 0.042 1.0x textgrid construct 8.555 0.031 8.7x parselmouth construct 206.68 3.39 210.0x gridio to_df 1.264 0.014 1.0x textgrid to_df 10.143 0.945 8.0x parselmouth to_df 220.11 5.23 174.1x <p></p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#functional-helpers","title":"Functional Helpers","text":""},{"location":"api/#gridio","title":"<code>gridio</code>","text":"<p>High-level helpers for converting Praat TextGrid files.</p> <p>These wrappers expose the Rust-backed parsing and serialization implemented in :mod:<code>gridio.gridio</code> and provide convenient Pythonic utilities for turning TextGrid content into tabular or nested data structures and writing them back to disk.</p> <p>Functions:</p> Name Description <code>textgrid_to_df</code> <p>Parse TextGrid files into a DataFrame-like structure.</p> <code>textgrid_to_data</code> <p>Parse TextGrid files into nested data resembling the Rust output.</p> <code>df_to_textgrid</code> <p>Serialize a tabular representation back into a TextGrid file.</p> <code>data_to_textgrid</code> <p>Write nested tier data to a TextGrid file using the Rust backend.</p>"},{"location":"api/#gridio.textgrid_to_df","title":"<code>textgrid_to_df(file, strict=False, file_type='auto', file_name_column=None, file_name_func=None, backend='pandas')</code>","text":"<p>Parse TextGrid files into a DataFrame-like structure.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, list[str], Path, list[Path]]</code> <p>Path to a single TextGrid file or an iterable of paths.</p> required <code>strict</code> <code>bool</code> <p>When <code>True</code> the parser raises on malformed structures instead of attempting a best-effort conversion.</p> <code>False</code> <code>file_type</code> <code>str</code> <p><code>\"short\"</code>, <code>\"long\"</code>, or <code>\"auto\"</code> to let the backend infer the dialect.</p> <code>'auto'</code> <code>file_name_column</code> <code>Optional[bool]</code> <p>Force inclusion (<code>True</code>) or exclusion (<code>False</code>) of a filename column. Defaults to <code>True</code> for multi-file inputs and <code>False</code> otherwise.</p> <code>None</code> <code>file_name_func</code> <code>Optional[Any]</code> <p>Optional callable used to transform each filename before it is written to the DataFrame. The callable receives the original path object and must return a string.</p> <code>None</code> <code>backend</code> <code>Literal['pandas', 'polars']</code> <p><code>\"pandas\"</code> yields a :class:<code>pandas.DataFrame</code>; <code>\"polars\"</code> yields a :class:<code>polars.DataFrame</code>.</p> <code>'pandas'</code> <p>Returns:</p> Type Description <code>DataFrame or DataFrame</code> <p>Tabular representation containing <code>tmin</code>, <code>tmax</code>, <code>label</code>, <code>tier</code> and interval flags; optionally includes <code>filename</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = textgrid_to_df(\"data/short_format.TextGrid\")\n&gt;&gt;&gt; df.head().to_dict(orient=\"records\")\n[{'tmin': 0.0, 'tmax': 0.25, 'label': 'sil', 'tier': 'phones',\n  'is_interval': True},\n {'tmin': 0.25, 'tmax': 0.53, 'label': 's', 'tier': 'phones',\n  'is_interval': True}]\n</code></pre> <p>The primary columns are <code>tmin</code>, <code>tmax</code>, <code>label</code>, <code>tier</code>, <code>is_interval</code>, and (for multi-file inputs) <code>filename</code>.</p> See Also <p>df_to_textgrid : Persist the DataFrame back to a TextGrid file.</p> Source code in <code>gridio/__init__.py</code> <pre><code>def textgrid_to_df(\n    file: Union[str, list[str], Path, list[Path]],\n    strict: bool = False,\n    file_type: str = \"auto\",\n    file_name_column: Optional[bool] = None,\n    file_name_func: Optional[Any] = None,\n    backend: Literal[\"pandas\", \"polars\"] = \"pandas\",\n):\n    \"\"\"Parse TextGrid files into a DataFrame-like structure.\n\n    Parameters\n    ----------\n    file:\n        Path to a single TextGrid file or an iterable of paths.\n    strict:\n        When ``True`` the parser raises on malformed structures instead of\n        attempting a best-effort conversion.\n    file_type:\n        ``\"short\"``, ``\"long\"``, or ``\"auto\"`` to let the backend infer the\n        dialect.\n    file_name_column:\n        Force inclusion (``True``) or exclusion (``False``) of a filename column.\n        Defaults to ``True`` for multi-file inputs and ``False`` otherwise.\n    file_name_func:\n        Optional callable used to transform each filename before it is written\n        to the DataFrame. The callable receives the original path object and\n        must return a string.\n    backend:\n        ``\"pandas\"`` yields a :class:`pandas.DataFrame`; ``\"polars\"`` yields a\n        :class:`polars.DataFrame`.\n\n    Returns\n    -------\n    pandas.DataFrame or polars.DataFrame\n        Tabular representation containing ``tmin``, ``tmax``, ``label``, ``tier``\n        and interval flags; optionally includes ``filename``.\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = textgrid_to_df(\"data/short_format.TextGrid\")\n    &gt;&gt;&gt; df.head().to_dict(orient=\"records\")  # doctest: +SKIP\n    [{'tmin': 0.0, 'tmax': 0.25, 'label': 'sil', 'tier': 'phones',\n      'is_interval': True},\n     {'tmin': 0.25, 'tmax': 0.53, 'label': 's', 'tier': 'phones',\n      'is_interval': True}]\n\n    The primary columns are ``tmin``, ``tmax``, ``label``, ``tier``,\n    ``is_interval``, and (for multi-file inputs) ``filename``.\n\n    See Also\n    --------\n    df_to_textgrid : Persist the DataFrame back to a TextGrid file.\n    \"\"\"\n    if file_name_column is None:\n        file_name_column = isinstance(file, list)\n\n    vectors = _dispatch_files(\n        file,\n        func_single=lambda f: rc_tg2vecs(f, strict=strict, file_type=file_type),\n        func_multiple=lambda fs: rc_tgs2vecs(fs, strict=strict, file_type=file_type),\n    )\n\n    tmins, tmaxs, labels, tiers, is_intervals = vectors[:5]\n\n    data = {\n        \"tmin\": tmins,\n        \"tmax\": tmaxs,\n        \"label\": np.array(labels, dtype=np.str_),\n        \"tier\": np.array(tiers, dtype=np.str_),\n        \"is_interval\": is_intervals,\n    }\n\n    if file_name_column:\n        file_names = _file_name(file, file_name_func=file_name_func)\n        if isinstance(file, (str, Path)):\n            file_names = np.repeat(file_names, len(tiers))\n        else:\n            file_ids = vectors[5]\n            file_names = np.array(file_names, dtype=np.str_)[file_ids]\n        data[\"filename\"] = file_names\n\n    if backend == \"pandas\":\n        import pandas as pd\n\n        df = pd.DataFrame(data, copy=False)\n    elif backend == \"polars\":\n        import polars as pl\n\n        df = pl.DataFrame(data)\n    else:\n        raise ValueError(\"backend must be 'pandas' or 'polars'\")\n    return df\n</code></pre>"},{"location":"api/#gridio.textgrid_to_data","title":"<code>textgrid_to_data(file, strict=False, file_name_func=None, file_type='auto')</code>","text":"<p>Parse TextGrid files into nested data resembling the Rust output.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Union[str, list[str], Path, list[Path]]</code> <p>Path to a single TextGrid file or an iterable of paths.</p> required <code>strict</code> <code>bool</code> <p>When <code>True</code> enforce strict parsing.</p> <code>False</code> <code>file_name_func</code> <code>Optional[Any]</code> <p>Optional callable used to transform each filename key in the returned dictionary for multi-file inputs.</p> <code>None</code> <code>file_type</code> <code>str</code> <p><code>\"short\"</code>, <code>\"long\"</code> or <code>\"auto\"</code> to control dialect detection.</p> <code>'auto'</code> <p>Returns:</p> Type Description <code>tuple or dict[str, tuple]</code> <p>The raw structured data from the Rust bindings. For multiple files a dictionary keyed by filename is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = textgrid_to_data(\"data/short_format.TextGrid\")\n&gt;&gt;&gt; round(data[0], 2), round(data[1], 2)\n(0.0, 2.43)\n&gt;&gt;&gt; data[2][0]\n('phones', True, [(0.0, 0.25, 'sil'), (0.25, 0.53, 's')])\n</code></pre> <p>The tuple layout is <code>(tmin, tmax, tiers)</code>. Each tier entry is <code>(name, is_interval, items)</code> where <code>items</code> is an ordered list of <code>(start, end, label)</code> tuples. Point tiers repeat their timestamp for <code>start</code> and <code>end</code> so the shape remains consistent with interval tiers.</p> <p>With multiple input files the function returns a dictionary mapping the normalised filename (after applying <code>file_name_func</code> when provided) to the same tuple structure.</p> See Also <p>data_to_textgrid : Convert the tuple structure back into a TextGrid file.</p> Source code in <code>gridio/__init__.py</code> <pre><code>def textgrid_to_data(\n    file: Union[str, list[str], Path, list[Path]],\n    strict: bool = False,\n    file_name_func: Optional[Any] = None,\n    file_type: str = \"auto\",\n):\n    \"\"\"Parse TextGrid files into nested data resembling the Rust output.\n\n    Parameters\n    ----------\n    file:\n        Path to a single TextGrid file or an iterable of paths.\n    strict:\n        When ``True`` enforce strict parsing.\n    file_name_func:\n        Optional callable used to transform each filename key in the returned\n        dictionary for multi-file inputs.\n    file_type:\n        ``\"short\"``, ``\"long\"`` or ``\"auto\"`` to control dialect detection.\n\n    Returns\n    -------\n    tuple or dict[str, tuple]\n        The raw structured data from the Rust bindings. For multiple files a\n        dictionary keyed by filename is returned.\n\n    Examples\n    --------\n    &gt;&gt;&gt; data = textgrid_to_data(\"data/short_format.TextGrid\")\n    &gt;&gt;&gt; round(data[0], 2), round(data[1], 2)\n    (0.0, 2.43)\n    &gt;&gt;&gt; data[2][0]\n    ('phones', True, [(0.0, 0.25, 'sil'), (0.25, 0.53, 's')])\n\n    The tuple layout is ``(tmin, tmax, tiers)``. Each tier entry is\n    ``(name, is_interval, items)`` where ``items`` is an ordered list of\n    ``(start, end, label)`` tuples. Point tiers repeat their timestamp for\n    ``start`` and ``end`` so the shape remains consistent with interval tiers.\n\n    With multiple input files the function returns a dictionary mapping the\n    normalised filename (after applying ``file_name_func`` when provided) to the\n    same tuple structure.\n\n    See Also\n    --------\n    data_to_textgrid : Convert the tuple structure back into a TextGrid file.\n    \"\"\"\n\n    data = _dispatch_files(\n        file,\n        func_single=lambda f: rc_tg2data(f, strict=strict, file_type=file_type),\n        func_multiple=lambda fs: rc_tgs2data(fs, strict=strict, file_type=file_type),\n    )\n    if isinstance(file, (str, Path)):\n        return data\n    file_names = _file_name(file, file_name_func=file_name_func)\n    return {file_name: file_data for file_name, file_data in zip(file_names, data)}\n</code></pre>"},{"location":"api/#gridio.df_to_textgrid","title":"<code>df_to_textgrid(df, out_file, tmin=None, tmax=None, file_type='long')</code>","text":"<p>Serialize a tabular representation back into a TextGrid file.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>Any</code> <p>DataFrame-like object exposing <code>tmin</code>, <code>tmax</code>, <code>label</code>, <code>tier</code> and <code>is_interval</code> columns.</p> required <code>out_file</code> <code>str</code> <p>Destination path for the emitted TextGrid file.</p> required <code>tmin</code> <code>Optional[float]</code> <p>Optional overrides for the global bounds written to the file.</p> <code>None</code> <code>tmax</code> <code>Optional[float]</code> <p>Optional overrides for the global bounds written to the file.</p> <code>None</code> <code>file_type</code> <code>str</code> <p>Dialect to emit (<code>\"short\"</code> or <code>\"long\"</code>).</p> <code>'long'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; df = textgrid_to_df(\"data/short_format.TextGrid\")\n&gt;&gt;&gt; df_to_textgrid(df, \"out.TextGrid\", file_type=\"short\")\n</code></pre> <p>The converter expects the same column layout described in :func:<code>textgrid_to_df</code>.</p> See Also <p>textgrid_to_df : Parse TextGrid files into the expected DataFrame format.</p> Source code in <code>gridio/__init__.py</code> <pre><code>def df_to_textgrid(\n    df: Any,\n    out_file: str,\n    tmin: Optional[float] = None,\n    tmax: Optional[float] = None,\n    file_type: str = \"long\",\n):\n    \"\"\"Serialize a tabular representation back into a TextGrid file.\n\n    Parameters\n    ----------\n    df:\n        DataFrame-like object exposing ``tmin``, ``tmax``, ``label``, ``tier``\n        and ``is_interval`` columns.\n    out_file:\n        Destination path for the emitted TextGrid file.\n    tmin, tmax:\n        Optional overrides for the global bounds written to the file.\n    file_type:\n        Dialect to emit (``\"short\"`` or ``\"long\"``).\n\n    Examples\n    --------\n    &gt;&gt;&gt; df = textgrid_to_df(\"data/short_format.TextGrid\")\n    &gt;&gt;&gt; df_to_textgrid(df, \"out.TextGrid\", file_type=\"short\")  # doctest: +SKIP\n\n    The converter expects the same column layout described in\n    :func:`textgrid_to_df`.\n\n    See Also\n    --------\n    textgrid_to_df : Parse TextGrid files into the expected DataFrame format.\n    \"\"\"\n    tmins = df[\"tmin\"].tolist()\n    tmaxs = df[\"tmax\"].tolist()\n    labels = df[\"label\"].tolist()\n    tiers = df[\"tier\"].tolist()\n    is_intervals = df[\"is_interval\"].tolist()\n    rc_vecs2tg(\n        tmins,\n        tmaxs,\n        labels,\n        tiers,\n        is_intervals,\n        tmin,\n        tmax,\n        out_file,\n        file_type=file_type,\n    )\n</code></pre>"},{"location":"api/#gridio.data_to_textgrid","title":"<code>data_to_textgrid(data, out_file, file_type='long')</code>","text":"<p>Write nested tier data to a TextGrid file using the Rust backend.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Tuple of <code>(tmin, tmax, tiers)</code> as returned by :func:<code>textgrid_to_data</code>.</p> required <code>out_file</code> <code>str</code> <p>Destination path for the serialized TextGrid.</p> required <code>file_type</code> <code>str</code> <p>Dialect to emit (<code>\"short\"</code> or <code>\"long\"</code>).</p> <code>'long'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; data = textgrid_to_data(\"data/short_format.TextGrid\")\n&gt;&gt;&gt; data_to_textgrid(data, \"out.TextGrid\", file_type=\"long\")\n</code></pre> <p>Refer to :func:<code>textgrid_to_data</code> for details on the expected tuple layout.</p> See Also <p>textgrid_to_data : Produce the tuple structure consumed by this helper.</p> Source code in <code>gridio/__init__.py</code> <pre><code>def data_to_textgrid(\n    data: Any,\n    out_file: str,\n    file_type: str = \"long\",\n):\n    \"\"\"Write nested tier data to a TextGrid file using the Rust backend.\n\n    Parameters\n    ----------\n    data:\n        Tuple of ``(tmin, tmax, tiers)`` as returned by :func:`textgrid_to_data`.\n    out_file:\n        Destination path for the serialized TextGrid.\n    file_type:\n        Dialect to emit (``\"short\"`` or ``\"long\"``).\n\n    Examples\n    --------\n    &gt;&gt;&gt; data = textgrid_to_data(\"data/short_format.TextGrid\")\n    &gt;&gt;&gt; data_to_textgrid(data, \"out.TextGrid\", file_type=\"long\")  # doctest: +SKIP\n\n    Refer to :func:`textgrid_to_data` for details on the expected tuple layout.\n\n    See Also\n    --------\n    textgrid_to_data : Produce the tuple structure consumed by this helper.\n    \"\"\"\n    tmin, tmax, tiers = data\n    rc_data2tg(tiers, tmin, tmax, out_file, file_type=file_type)\n</code></pre>"},{"location":"api/#object-oriented-api","title":"Object-Oriented API","text":""},{"location":"api/#gridio.textgrid","title":"<code>gridio.textgrid</code>","text":"<p>Classes:</p> Name Description <code>IntervalItem</code> <p>Lightweight container for a single interval tier entry.</p> <code>IntervalTier</code> <p>Tier containing interval items spanning start and end times.</p> <code>PointItem</code> <p>Container for a point tier entry stored at a single timestamp.</p> <code>PointTier</code> <p>Tier containing point items at discrete timestamps.</p> <code>TextGrid</code> <p>In-memory representation of a Praat TextGrid document.</p> <code>Tier</code> <p>Mutable collection of TextGrid items with a shared tier name.</p>"},{"location":"api/#gridio.textgrid.IntervalItem","title":"<code>IntervalItem</code>","text":"<p>Lightweight container for a single interval tier entry.</p> <p>Parameters:</p> Name Type Description Default <code>tmin</code> <code>float</code> <p>Start and end boundaries in seconds.</p> required <code>tmax</code> <code>float</code> <p>Start and end boundaries in seconds.</p> required <code>label</code> <code>str</code> <p>Text label associated with the interval.</p> required <p>Attributes:</p> Name Type Description <code>data</code> <p>Return the tuple representation consumed by the Rust backend.</p> Source code in <code>gridio/textgrid.py</code> <pre><code>class IntervalItem:\n    \"\"\"Lightweight container for a single interval tier entry.\n\n    Parameters\n    ----------\n    tmin, tmax : float\n        Start and end boundaries in seconds.\n    label : str\n        Text label associated with the interval.\n    \"\"\"\n\n    def __init__(self, tmin, tmax, label):\n        self.tmin = tmin\n        self.tmax = tmax\n        self.label = label\n\n    @property\n    def data(self):\n        \"\"\"Return the tuple representation consumed by the Rust backend.\"\"\"\n        return (self.tmin, self.tmax, self.label)\n</code></pre>"},{"location":"api/#gridio.textgrid.IntervalItem.data","title":"<code>data</code>  <code>property</code>","text":"<p>Return the tuple representation consumed by the Rust backend.</p>"},{"location":"api/#gridio.textgrid.IntervalTier","title":"<code>IntervalTier</code>","text":"<p>               Bases: <code>Tier</code></p> <p>Tier containing interval items spanning start and end times.</p> <p>Methods:</p> Name Description <code>get_item</code> <p>Return the :class:<code>IntervalItem</code> stored at <code>index</code>.</p> Source code in <code>gridio/textgrid.py</code> <pre><code>class IntervalTier(Tier):\n    \"\"\"Tier containing interval items spanning start and end times.\"\"\"\n\n    def __init__(self, name):\n        super().__init__(name, True)\n\n    def get_item(self, index: int) -&gt; IntervalItem:\n        \"\"\"Return the :class:`IntervalItem` stored at ``index``.\"\"\"\n        item_data = self._items[index]\n        return IntervalItem(item_data[0], item_data[1], item_data[2])\n</code></pre>"},{"location":"api/#gridio.textgrid.IntervalTier.get_item","title":"<code>get_item(index)</code>","text":"<p>Return the :class:<code>IntervalItem</code> stored at <code>index</code>.</p> Source code in <code>gridio/textgrid.py</code> <pre><code>def get_item(self, index: int) -&gt; IntervalItem:\n    \"\"\"Return the :class:`IntervalItem` stored at ``index``.\"\"\"\n    item_data = self._items[index]\n    return IntervalItem(item_data[0], item_data[1], item_data[2])\n</code></pre>"},{"location":"api/#gridio.textgrid.PointItem","title":"<code>PointItem</code>","text":"<p>Container for a point tier entry stored at a single timestamp.</p> <p>Parameters:</p> Name Type Description Default <code>time</code> <code>float</code> <p>Absolute time position in seconds.</p> required <code>label</code> <code>str</code> <p>Text label associated with the point.</p> required <p>Attributes:</p> Name Type Description <code>data</code> <p>Represent the point as <code>(time, time, label)</code> for uniform storage.</p> Source code in <code>gridio/textgrid.py</code> <pre><code>class PointItem:\n    \"\"\"Container for a point tier entry stored at a single timestamp.\n\n    Parameters\n    ----------\n    time : float\n        Absolute time position in seconds.\n    label : str\n        Text label associated with the point.\n    \"\"\"\n\n    def __init__(self, time, label):\n        self.time = time\n        self.label = label\n\n    @property\n    def data(self):\n        \"\"\"Represent the point as ``(time, time, label)`` for uniform storage.\"\"\"\n        return (self.time, self.time, self.label)\n</code></pre>"},{"location":"api/#gridio.textgrid.PointItem.data","title":"<code>data</code>  <code>property</code>","text":"<p>Represent the point as <code>(time, time, label)</code> for uniform storage.</p>"},{"location":"api/#gridio.textgrid.PointTier","title":"<code>PointTier</code>","text":"<p>               Bases: <code>Tier</code></p> <p>Tier containing point items at discrete timestamps.</p> <p>Methods:</p> Name Description <code>get_item</code> <p>Return the :class:<code>PointItem</code> stored at <code>index</code>.</p> Source code in <code>gridio/textgrid.py</code> <pre><code>class PointTier(Tier):\n    \"\"\"Tier containing point items at discrete timestamps.\"\"\"\n\n    def __init__(self, name):\n        super().__init__(name, False)\n\n    def get_item(self, index: int) -&gt; PointItem:\n        \"\"\"Return the :class:`PointItem` stored at ``index``.\"\"\"\n        item_data = self._items[index]\n        return PointItem(item_data[0], item_data[2])\n</code></pre>"},{"location":"api/#gridio.textgrid.PointTier.get_item","title":"<code>get_item(index)</code>","text":"<p>Return the :class:<code>PointItem</code> stored at <code>index</code>.</p> Source code in <code>gridio/textgrid.py</code> <pre><code>def get_item(self, index: int) -&gt; PointItem:\n    \"\"\"Return the :class:`PointItem` stored at ``index``.\"\"\"\n    item_data = self._items[index]\n    return PointItem(item_data[0], item_data[2])\n</code></pre>"},{"location":"api/#gridio.textgrid.TextGrid","title":"<code>TextGrid</code>","text":"<p>In-memory representation of a Praat TextGrid document.</p> <p>Parameters:</p> Name Type Description Default <code>tmin</code> <code>float</code> <p>Global bounds for all tiers. They are preserved when saving if not overridden.</p> <code>None</code> <code>tmax</code> <code>float</code> <p>Global bounds for all tiers. They are preserved when saving if not overridden.</p> <code>None</code> <p>Methods:</p> Name Description <code>add_tier</code> <p>Insert <code>tier</code> at <code>where</code> (append when <code>where</code> is <code>-1</code>).</p> <code>from_file</code> <p>Read TextGrid files and wrap them in :class:<code>TextGrid</code> objects.</p> <code>get_tier</code> <p>Return a tier by numeric index or name, preserving subclass type.</p> <code>remove_tier</code> <p>Remove a tier, looking it up by name or numeric index.</p> <code>save</code> <p>Write the TextGrid to <code>out_file</code> using the Rust serializer.</p> <p>Attributes:</p> Name Type Description <code>data</code> <p>Return the backend-compatible tuple <code>(tmin, tmax, tiers)</code>.</p> <code>ntiers</code> <code>int</code> <p>Total number of tiers in the TextGrid.</p> Source code in <code>gridio/textgrid.py</code> <pre><code>class TextGrid:\n    \"\"\"In-memory representation of a Praat TextGrid document.\n\n    Parameters\n    ----------\n    tmin, tmax : float, optional\n        Global bounds for all tiers. They are preserved when saving if not\n        overridden.\n    \"\"\"\n\n    def __init__(self, tmin=None, tmax=None):\n        self.tmin = tmin\n        self.tmax = tmax\n        self._tiers = []\n\n    def _name2id(self, tier_name: str) -&gt; Optional[int]:\n        for i, tier in enumerate(self._tiers):\n            if tier[0] == tier_name:\n                return i\n        return None\n\n    def _tier_route(self, indexer=None, tier_name=None, tier_id=None) -&gt; Optional[int]:\n        if not indexer is None:\n            if isinstance(indexer, int):\n                tier_id = indexer\n            elif isinstance(indexer, str):\n                tier_name = indexer\n            else:\n                raise TypeError(\"indexer must be int or str\")\n        if not tier_name is None:\n            tier_id = self._name2id(tier_name)\n        return tier_id\n\n    def get_tier(self, indexer=None, tier_name=None, tier_id=None) -&gt; Optional[Tier]:\n        \"\"\"Return a tier by numeric index or name, preserving subclass type.\"\"\"\n        tier_id = self._tier_route(\n            indexer=indexer, tier_name=tier_name, tier_id=tier_id\n        )\n        return Tier._from_data(self._tiers[tier_id])\n\n    def add_tier(self, tier: Tier, where: int = -1):\n        \"\"\"Insert ``tier`` at ``where`` (append when ``where`` is ``-1``).\"\"\"\n        if where == -1:\n            where = len(self._tiers)\n        self._tiers.insert(where, tier.data)\n\n    def remove_tier(self, tier_name=None, tier_id=None):\n        \"\"\"Remove a tier, looking it up by name or numeric index.\"\"\"\n        tier_id = self._tier_route(tier_name=tier_name, tier_id=tier_id)\n        if tier_id is None:\n            return\n        self._tiers.pop(tier_id)\n\n    @property\n    def ntiers(self) -&gt; int:\n        \"\"\"Total number of tiers in the TextGrid.\"\"\"\n        return len(self._tiers)\n\n    @property\n    def data(self):\n        \"\"\"Return the backend-compatible tuple ``(tmin, tmax, tiers)``.\"\"\"\n        return (self.tmin, self.tmax, self._tiers)\n\n    def save(\n        self,\n        out_file: str,\n        file_type: str = \"long\",\n    ):\n        \"\"\"Write the TextGrid to ``out_file`` using the Rust serializer.\"\"\"\n        data_to_textgrid(self.data, out_file, file_type=file_type)\n\n    @staticmethod\n    def _from_data(data):\n        \"\"\"Build a :class:`TextGrid` instance from ``textgrid_to_data`` output.\"\"\"\n        tmin, tmax, tiers = data\n        tg = TextGrid(tmin, tmax)\n        tg._tiers = tiers\n        return tg\n\n    @staticmethod\n    def from_file(\n        file: Union[str, Path, list[str], list[Path]],\n        strict: bool = False,\n        file_type: str = \"auto\",\n        file_name_func: Optional[Any] = None,\n    ) -&gt; Union[\"TextGrid\", Dict[str, \"TextGrid\"]]:\n        \"\"\"Read TextGrid files and wrap them in :class:`TextGrid` objects.\"\"\"\n        tg_data = textgrid_to_data(\n            file,\n            strict=strict,\n            file_type=file_type,\n            file_name_func=file_name_func,\n        )\n        if isinstance(file, (str, Path)):\n            return TextGrid._from_data(tg_data)\n        else:\n            return {fname: TextGrid._from_data(data) for fname, data in tg_data.items()}\n</code></pre>"},{"location":"api/#gridio.textgrid.TextGrid.data","title":"<code>data</code>  <code>property</code>","text":"<p>Return the backend-compatible tuple <code>(tmin, tmax, tiers)</code>.</p>"},{"location":"api/#gridio.textgrid.TextGrid.ntiers","title":"<code>ntiers</code>  <code>property</code>","text":"<p>Total number of tiers in the TextGrid.</p>"},{"location":"api/#gridio.textgrid.TextGrid.add_tier","title":"<code>add_tier(tier, where=-1)</code>","text":"<p>Insert <code>tier</code> at <code>where</code> (append when <code>where</code> is <code>-1</code>).</p> Source code in <code>gridio/textgrid.py</code> <pre><code>def add_tier(self, tier: Tier, where: int = -1):\n    \"\"\"Insert ``tier`` at ``where`` (append when ``where`` is ``-1``).\"\"\"\n    if where == -1:\n        where = len(self._tiers)\n    self._tiers.insert(where, tier.data)\n</code></pre>"},{"location":"api/#gridio.textgrid.TextGrid.from_file","title":"<code>from_file(file, strict=False, file_type='auto', file_name_func=None)</code>  <code>staticmethod</code>","text":"<p>Read TextGrid files and wrap them in :class:<code>TextGrid</code> objects.</p> Source code in <code>gridio/textgrid.py</code> <pre><code>@staticmethod\ndef from_file(\n    file: Union[str, Path, list[str], list[Path]],\n    strict: bool = False,\n    file_type: str = \"auto\",\n    file_name_func: Optional[Any] = None,\n) -&gt; Union[\"TextGrid\", Dict[str, \"TextGrid\"]]:\n    \"\"\"Read TextGrid files and wrap them in :class:`TextGrid` objects.\"\"\"\n    tg_data = textgrid_to_data(\n        file,\n        strict=strict,\n        file_type=file_type,\n        file_name_func=file_name_func,\n    )\n    if isinstance(file, (str, Path)):\n        return TextGrid._from_data(tg_data)\n    else:\n        return {fname: TextGrid._from_data(data) for fname, data in tg_data.items()}\n</code></pre>"},{"location":"api/#gridio.textgrid.TextGrid.get_tier","title":"<code>get_tier(indexer=None, tier_name=None, tier_id=None)</code>","text":"<p>Return a tier by numeric index or name, preserving subclass type.</p> Source code in <code>gridio/textgrid.py</code> <pre><code>def get_tier(self, indexer=None, tier_name=None, tier_id=None) -&gt; Optional[Tier]:\n    \"\"\"Return a tier by numeric index or name, preserving subclass type.\"\"\"\n    tier_id = self._tier_route(\n        indexer=indexer, tier_name=tier_name, tier_id=tier_id\n    )\n    return Tier._from_data(self._tiers[tier_id])\n</code></pre>"},{"location":"api/#gridio.textgrid.TextGrid.remove_tier","title":"<code>remove_tier(tier_name=None, tier_id=None)</code>","text":"<p>Remove a tier, looking it up by name or numeric index.</p> Source code in <code>gridio/textgrid.py</code> <pre><code>def remove_tier(self, tier_name=None, tier_id=None):\n    \"\"\"Remove a tier, looking it up by name or numeric index.\"\"\"\n    tier_id = self._tier_route(tier_name=tier_name, tier_id=tier_id)\n    if tier_id is None:\n        return\n    self._tiers.pop(tier_id)\n</code></pre>"},{"location":"api/#gridio.textgrid.TextGrid.save","title":"<code>save(out_file, file_type='long')</code>","text":"<p>Write the TextGrid to <code>out_file</code> using the Rust serializer.</p> Source code in <code>gridio/textgrid.py</code> <pre><code>def save(\n    self,\n    out_file: str,\n    file_type: str = \"long\",\n):\n    \"\"\"Write the TextGrid to ``out_file`` using the Rust serializer.\"\"\"\n    data_to_textgrid(self.data, out_file, file_type=file_type)\n</code></pre>"},{"location":"api/#gridio.textgrid.Tier","title":"<code>Tier</code>","text":"<p>Mutable collection of TextGrid items with a shared tier name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Tier identifier as stored in the TextGrid.</p> required <code>is_interval</code> <code>bool</code> <p><code>True</code> for interval tiers, <code>False</code> for point tiers.</p> required <p>Methods:</p> Name Description <code>insert_item</code> <p>Insert a new item at <code>index</code> (append when <code>index</code> is <code>-1</code>).</p> <code>remove_item</code> <p>Remove the item at <code>index</code> from the tier.</p> <p>Attributes:</p> Name Type Description <code>data</code> <p>Return the tuple <code>(name, is_interval, items)</code> used by the bindings.</p> <code>nitems</code> <code>int</code> <p>Number of stored items.</p> Source code in <code>gridio/textgrid.py</code> <pre><code>class Tier:\n    \"\"\"Mutable collection of TextGrid items with a shared tier name.\n\n    Parameters\n    ----------\n    name : str\n        Tier identifier as stored in the TextGrid.\n    is_interval : bool\n        ``True`` for interval tiers, ``False`` for point tiers.\n    \"\"\"\n\n    def __init__(self, name, is_interval):\n        self.name = name\n        self.is_interval = is_interval\n        self._items = []\n\n    def insert_item(self, item, index: int = -1):\n        \"\"\"Insert a new item at ``index`` (append when ``index`` is ``-1``).\"\"\"\n        if index == -1:\n            index = len(self._items)\n        self._items.insert(index, item.data)\n\n    def remove_item(self, index: int):\n        \"\"\"Remove the item at ``index`` from the tier.\"\"\"\n        self._items.pop(index)\n\n    @property\n    def nitems(self) -&gt; int:\n        \"\"\"Number of stored items.\"\"\"\n        return len(self._items)\n\n    @property\n    def data(self):\n        \"\"\"Return the tuple ``(name, is_interval, items)`` used by the bindings.\"\"\"\n        return (self.name, self.is_interval, self._items)\n\n    @staticmethod\n    def _from_data(data):\n        \"\"\"Instantiate an appropriate tier subclass from backend data.\"\"\"\n        name, is_interval, items = data\n        if is_interval:\n            tier = IntervalTier(name)\n        else:\n            tier = PointTier(name)\n        tier._items = items\n        return tier\n</code></pre>"},{"location":"api/#gridio.textgrid.Tier.data","title":"<code>data</code>  <code>property</code>","text":"<p>Return the tuple <code>(name, is_interval, items)</code> used by the bindings.</p>"},{"location":"api/#gridio.textgrid.Tier.nitems","title":"<code>nitems</code>  <code>property</code>","text":"<p>Number of stored items.</p>"},{"location":"api/#gridio.textgrid.Tier.insert_item","title":"<code>insert_item(item, index=-1)</code>","text":"<p>Insert a new item at <code>index</code> (append when <code>index</code> is <code>-1</code>).</p> Source code in <code>gridio/textgrid.py</code> <pre><code>def insert_item(self, item, index: int = -1):\n    \"\"\"Insert a new item at ``index`` (append when ``index`` is ``-1``).\"\"\"\n    if index == -1:\n        index = len(self._items)\n    self._items.insert(index, item.data)\n</code></pre>"},{"location":"api/#gridio.textgrid.Tier.remove_item","title":"<code>remove_item(index)</code>","text":"<p>Remove the item at <code>index</code> from the tier.</p> Source code in <code>gridio/textgrid.py</code> <pre><code>def remove_item(self, index: int):\n    \"\"\"Remove the item at ``index`` from the tier.\"\"\"\n    self._items.pop(index)\n</code></pre>"},{"location":"benchmarks/","title":"Benchmarks","text":"<p>This document presents performance benchmarks comparing three popular Python libraries for parsing Praat TextGrid files:</p> <ol> <li>gridio (this project, backed by Rust bindings)</li> <li>textgrid (pure Python implementation)</li> <li>parselmouth (Python bridge to Praat''s C++ core)</li> </ol>"},{"location":"benchmarks/#overview","title":"Overview","text":"<p>The benchmark suite evaluates two common workflows:</p> <ul> <li>construct: Parse TextGrid files and construct in-memory objects</li> <li>to_df: Parse TextGrid files and convert them to Pandas DataFrames</li> </ul> <p>These tasks represent typical use cases in phonetic research, where researchers need to either work with TextGrid objects programmatically or analyze annotation data using DataFrame operations.</p>"},{"location":"benchmarks/#implementation-details","title":"Implementation Details","text":""},{"location":"benchmarks/#gridio","title":"gridio","text":"<pre><code>import gridio\n\n# Task 1: construct - Parse and create TextGrid objects\ntextgrids = gridio.TextGrid.from_file(file_list)\n\n# Task 2: to_df - Parse and convert to DataFrame\ndf = gridio.textgrid_to_df(file_list, strict=False, file_type=\"long\")\n</code></pre> <p>The <code>gridio.TextGrid.from_file()</code> method accepts either a single file path or a list of paths, enabling efficient batch processing with Rust-powered parallelization.</p>"},{"location":"benchmarks/#textgrid-pure-python","title":"textgrid (pure Python)","text":"<pre><code>import textgrid\nimport pandas as pd\n\n# Task 1: construct\ntextgrids = [textgrid.TextGrid.fromFile(f) for f in file_list]\n\n# Task 2: to_df\nrows = []\nfor fname, tg in zip(file_list, textgrids):\n    for tier in tg.tiers:\n        is_interval = isinstance(tier, textgrid.IntervalTier)\n        for item in tier:\n            if is_interval:\n                tmin, tmax, label = item.minTime, item.maxTime, item.mark\n            else:\n                tmin, tmax, label = item.time, item.time, item.mark\n            rows.append({\n                \"tmin\": tmin,\n                \"tmax\": tmax,\n                \"label\": label,\n                \"tier\": tier.name,\n                \"is_interval\": is_interval,\n                \"filename\": fname,\n            })\ndf = pd.DataFrame(rows)\n</code></pre>"},{"location":"benchmarks/#parselmouth","title":"parselmouth","text":"<pre><code>from functools import partial\nimport parselmouth\nimport pandas as pd\n\n# Task 1: construct\ndata_list = []\nfor fname in file_list:\n    tgt = parselmouth.TextGrid.read(str(fname))\n    Praat = partial(parselmouth.praat.call, tgt)\n\n    tgt_data = {\n        \"xmin\": Praat(\"Get start time\"),\n        \"xmax\": Praat(\"Get end time\"),\n        \"tiers\": [],\n    }\n    ntier = Praat(\"Get number of tiers\")\n    for tier_idx in range(1, ntier + 1):\n        tier = {\n            \"name\": Praat(\"Get tier name\", tier_idx),\n            \"is_interval\": Praat(\"Is interval tier\", tier_idx),\n            \"items\": [],\n        }\n        if tier[\"is_interval\"]:\n            nitems = Praat(\"Get number of intervals\", tier_idx)\n            for j in range(1, nitems + 1):\n                tier[\"items\"].append({\n                    \"tmin\": Praat(\"Get start time of interval\", tier_idx, j),\n                    \"tmax\": Praat(\"Get end time of interval\", tier_idx, j),\n                    \"label\": Praat(\"Get label of interval\", tier_idx, j),\n                })\n        else:\n            nitems = Praat(\"Get number of points\", tier_idx)\n            for j in range(1, nitems + 1):\n                tier[\"items\"].append({\n                    \"point\": Praat(\"Get time of point\", tier_idx, j),\n                    \"label\": Praat(\"Get label of point\", tier_idx, j),\n                })\n        tgt_data[\"tiers\"].append(tier)\n    data_list.append(tgt_data)\n\n# Task 2: to_df (similar nested loop structure)\n</code></pre>"},{"location":"benchmarks/#benchmark-configuration-test-environment","title":"Benchmark Configuration &amp; Test Environment","text":"<p>The test corpus simulates a realistic scenario with moderate-sized annotation files, consists of 5,000 TextGrid files, each containing 2 interval tiers with 50 intervals each, 2 point tiers with 50 points each, and stored in Long format TextGrid files.</p> <p>Benchmarks were conducted on a laptop with the following specifications:</p> <ul> <li>OS: Windows 11 (25H2)</li> <li>CPU: 12th Gen Intel\u00ae Core\u2122 i5-12500H</li> <li>RAM: 16 GB</li> <li>Python: 3.12.7 (64-bit)</li> <li>gridio: Latest version (Rust-backed)</li> <li>textgrid: 1.6.1</li> <li>parselmouth: 0.4.5</li> <li>pandas: 2.2.3</li> </ul> <p>Each benchmark was repeated 5 times with a warm-up run to eliminate cold-start effects.</p>"},{"location":"benchmarks/#results","title":"Results","text":""},{"location":"benchmarks/#summary-statistics","title":"Summary Statistics","text":"<p>The table below shows mean execution time across 5 runs, with standard deviation and the speedup factor relative to the fastest implementation:</p> Package Task Mean (s) Std Dev (s) Speedup gridio construct 0.984 0.042 1.0x textgrid construct 8.555 0.031 8.7x parselmouth construct 206.68 3.39 210.0x gridio to_df 1.264 0.014 1.0x textgrid to_df 10.143 0.945 8.0x parselmouth to_df 220.11 5.23 174.1x"},{"location":"benchmarks/#visualization","title":"Visualization","text":"<p>Figure: Comparison of execution times for parsing 5,000 TextGrid files. The bars show mean execution time with error bars indicating standard deviation. Numbers on bars indicate absolute time (seconds) and relative speedup (x) compared to the fastest method. The x axis has been sqrt-scaled for clarity.</p>"},{"location":"benchmarks/#key-findings","title":"Key Findings","text":"<p><code>gridio</code> dominates both tasks. It's ~8x faster than <code>textgrid</code> and over 170x faster than <code>parselmouth</code>. You should prefer <code>gridio</code> for large-scale TextGrid processing due to its superior performance.</p>"},{"location":"benchmarks/#running-the-benchmark","title":"Running the Benchmark","text":"<p>To reproduce these results:</p> <pre><code>cd benchmarks\npython benchmark.py\n</code></pre> <p>Modifications to the benchmark parameters (e.g., number of files, tiers, intervals) can be made in <code>benchmark.py</code>.</p> <p>To visualize the results:</p> <pre><code># Open plot.Rmd in VSCode/RStudio and run the code chunks\n# Or use the R terminal:\ncd benchmarks\nRscript -e \"rmarkdown::render('plot.Rmd')\"\n</code></pre> <p>This generates <code>benchmark_plot.png</code> in the <code>benchmarks/results/</code> directory.</p>"}]}